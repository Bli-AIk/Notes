# 《重构》笔记

1. 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。
   - 需求变化使得重构必要。如果代码正常且不再修改，完全可以不重构。
   - 能改进当然好，但如果没人需要理解，就不会造成困扰。如果有人觉得理解困难，那就需要改进代码。

2. 重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。
   - 确保即将修改的代码拥有一组可靠的测试。
   - “测试”类似于bug检测器，它必须能自我检查，以确保在修改代码后，程序还能正常工作，避免引入新的错误。

3. 每次做完重构后，无论修改多小，都需要编译并确认是否出现问题。
   - 重构的精髓：小步修改，每次修改后就运行测试

4. 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。

5. 把代码推送push到远端仓库前，最好把零碎的修改压缩成一个更有意义的提交commit。

6. 傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。
   - 善用改名等方式提高代码可读性。

7. 尽管将函数变量改变成函数声明也是一种重构手法，但此手法未被命名，也未纳入重构名录。
    - 还有很多的重构手法没那么重要。例如函数改名的手法，它既十分简单又不太常用，不值得在重构名录中占有一席之地。
8. 对于重构过程的性能问题，总体的建议是：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。

9. 在事情变复杂时，第一反应是采用更小的步子。
   - 怎样算变复杂呢，就是当重构过程有测试失败而我又无法马上看清问题所在并立即修复时，我就会回滚到最后一次可工作的提交，然后以更小的步子重做。这得益于我如此频繁地提交。特别是与复杂代码打交道时，细小的步子是快速前进的关键。

10. 编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。

11. 好代码的检验标准就是人们是否能轻而易举地修改它。

12. 如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。
   - 重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。

13. 重构与性能优化有很多相似之处：两者都需要修改代码，并且两者都不会改变程序的整体功能。两者的差别在于其目的：重构是为了让代码“更容易理解，更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。
   - 重构之后的代码不一定与重构前行为完全一致
   - 在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护，对此我有心理准备

14. **两顶帽子**：Kent Beck 提出，在软件开发中应当区分添加新功能和重构两种行为。
   - 添加新功能时，专注于实现新功能，不修改已有代码，通过测试评估进度；重构时，专注调整代码结构，不添加功能，除非必要时才修改测试。在开发过程中，开发者会频繁切换这两种行为，以优化代码和提升开发效率。

15. 重构是一个工具，它可以并且应该用于以下几个目的：
   1. **重构改进软件的设计**：
      - 如果没有重构，程序的内部设计会逐渐腐败，代码结构的流失会加速腐败的过程。
      - 缺乏对架构整体的理解，程序员为短期目的修改代码，导致设计意图越来越难理解。
      - 设计欠佳的程序往往需要更多代码，增加理解和修改难度。
      - 通过消除重复代码，可以减少冗余，确保行为在代码中只表述一次，这也是优秀设计的核心。
      - 经常性重构有助于维持代码的结构和设计完整性。
   2. **重构使软件更容易理解**：
      - 程序设计的核心在于准确表达我想要计算机执行的任务，填补“我想要它做什么”和“我告诉它做什么”之间的差距。
      - 然而，除了计算机，代码的读者还有未来可能修改代码的程序员，他们才是最重要的。
      - 代码的易读性比效率更关键，因为难以理解的代码会大大增加维护和修改的时间。
      - 编写代码时，我们常忽视未来的读者，甚至是未来的自己。
      - 通过重构，代码可以更加清晰地表达意图，减轻未来开发者尤其是自己阅读和修改的负担，避免浪费时间去重新理解代码。
   3. **重构帮助找到 bug**：
      - 对代码的深入理解能够帮助发现 bug。
      - 人们并不擅长直接从代码中找 bug，但通过重构，你能够更好地理解代码的行为，并在过程中验证自己的假设，从而更容易找到问题。
   4. **重构提高编程速度**：
      - 重构确实提高了设计、可读性和质量，但并不会拖慢开发速度。
      - 很多开发者的经验表明，随着时间推移，未经过重构的代码库会越来越难维护，添加新功能变得缓慢，bug 也更加频繁。
      - 而良好的内部设计和清晰的代码结构使修改和扩展更容易、bug 更少，调试也更简单。
      - 这形成了“设计耐久性假说”：通过改善内部设计，我们延长了软件的开发效率。
      - 总之，重构让我们可以在开发过程中持续优化设计，而不是依赖于一开始的完美设计。

16. **何时重构**：遵循三次法则——事不过三，三就重构。
    - 第一次做某件事时只管去做；
    - 第二次做类似的事会产生反感，但无论如何还是可以去做；
    - 第三次再做类似的事，你就应该重构。

17. **重构的时间点**：
      1. **预备性重构**：让添加新功能更容易。
         - 重构的最佳时机是在添加新功能之前。添加新功能前，查看现有代码，并微调代码结构，可以简化工作流程。
         - 例如，若已有函数能满足大部分需求，我应避免复制粘贴，而是通过参数化来重构函数，以防止重复代码带来的维护麻烦——这种预备性重构就像规划最佳路线，能显著提高开发效率。
         - 修复 bug 时同样如此，合并重复代码或将更新逻辑与查询逻辑分开，有助于简化问题的解决，并降低再次出现相同 bug 的可能性。
         - 总之，预备性重构不仅能改善代码质量，还能提高未来开发的效率。
      2. **帮助理解的重构**：使代码更易懂。
         - 理解代码的首要步骤是明确其功能，而重构可以改善代码结构和命名，使其更清晰，进而揭示潜在的设计问题。
         - 通过重构，能够将对代码的理解转移到代码本身，提高可读性，促进未来维护——初步重构如同扫去窗上的尘埃，帮助开发者看到更广阔的视野，并发现潜在机会。
      3. **捡垃圾式重构**
         - 在理解代码后，如果发现其存在问题，例如逻辑复杂或函数重复，便可以进行必要的重构。
         - 若重构简单则立即处理；若耗时较长，则记下待办事项，待完成当前任务后再回头处理。
         - 像这样适当的“捡垃圾”工作是值得的，逐步改善代码可保持其整洁。每次小幅度的改进都不会破坏代码，持续改进最终会消除这些“垃圾”。
      4. **有计划的重构和见机行事的重构**
         - 预备性重构、帮助理解的重构和捡垃圾式重构属于见机行事的重构，通常是在添加功能或修复 bug 时顺便进行。
         - 这种重构是编程过程的自然组成部分，能帮助当前任务并减轻未来工作负担。要知道，重构并非与编程割裂的行为，而是与功能开发紧密相连。
         - 但尽管见机行事的重构更重要，有时团队可能需要专门安排时间有计划的进行重构，特别是在过去忽视重构的情况下。
         - 有计划的重构可以带来长远的价值，但应相对少见。
      5. **长期重构**
         - 虽然大多数重构可以在几分钟到几小时内完成，但一些大型重构可能需要数周时间，例如替换库或抽取组件。
         - 即便如此，不建议整个团队专门进行重构，而是可以达成共识，逐步解决问题。         
      6. **复审代码时重构**
      7. **何时不应该重构**
         - 重构并不总是值得的。若代码凌乱但不需修改，则无需重构；如果丑陋的代码可以隐藏在 API 之下，也可容忍。
         - 另外，如果重写比重构更容易，应选择重写。这个决定需要判断力和经验，没有简单规则可循。
         
18. 肮脏的代码必须重构，但漂亮的代码也需要很多重构。
   - 重构常被误解为仅针对肮脏的代码，但即使是漂亮的代码也需要重构。
   - 在编码过程中，会进行各种权衡，比如参数化的程度和函数之间的边界。
   - 这些在当时看似合理的决策，可能随着新功能的添加而变得不再适用。
   - 整洁的代码在需要调整这些权衡时，重构起来会更加容易。
19. 每次要修改时，首先令修改很容易_（警告：这件事有时会很难）_，然后再进行这次容易的修改。
   - 长期以来，编写软件被视为累加过程，添加新功能意味着增加新代码。
   - 然而，优秀的程序员知道，最快的方式往往是先修改现有代码，使新功能更容易添加。
   - 因此，软件不应被视为“完成”，每当需要新功能时，软件都应相应调整。
   - 尤其是在已有代码中，进行这些改变显得尤为重要。
20. 重构会带来的挑战：
    1. 延缓新功能开发
        - 在面对大规模重构和小功能添加时，需要权衡。虽然重构能提高修改便利性，但在某些情况下，优先添加新功能可能更合理。
        - 预备性重构可以使新功能开发更顺利，尤其是在已知问题的代码中。对于不常接触的代码，通常可以选择不重构。缺乏清晰的优化方向时，可能需要延迟重构，甚至先进行实验。
        - 重构的决策应基于经济效益，旨在提升功能添加和 bug 修复的速度，强调这一点可以帮助开发者更好地理解重构的价值。
        
    2. 代码所有权
    3. 分支
    4. 测试
        - 重构应确保不改变程序的可观察行为，但错误难免发生，因此需要及时发现并修正。为此，必须具备完备的、运行快速的测试套件，以便频繁运行，确保代码安全。
        - 自测试代码使重构成为可能，并降低引入新 bug 的风险。一旦测试失败，可以迅速定位最近修改的代码，排查问题会更容易。如果缺乏测试，可以依赖自动化重构工具，尽管这会限制可用的重构方法。
        - 另一种方法是仅使用已验证安全的重构手法，这对低测试覆盖率的代码库尤为重要。自测试代码与持续集成密切相关，二者共同确保代码质量和可靠性。
        
    5. 遗留代码
    6. 数据库
21. 代码的坏味道
    1. 神秘命名
        - 整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。
        - 改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。
    2. 重复代码
        - 当发现相同的代码出现在多个地方时，应尽可能将其合并以简化程序。
        - 重复代码不仅增加了阅读和理解的难度，还在修改时要求找到所有副本一并更新。
        
    3. 过长函数
        - 短小的函数有助于程序的理解与维护。尽管小函数可能导致频繁的上下文切换，但良好的命名能够消除这一负担。小函数通过提升阐释力、易于复用和更多选择性，提高了代码的可维护性。
        - 要减少函数长度，通常可以使用提炼函数的方法，将功能明确的代码段提取为独立函数。
        - 临时变量和参数过多时，可通过以查询取代临时变量、引入参数对象等方法优化。
        - 对于复杂的逻辑如条件表达式和循环，使用分解条件表达式和拆分循环等技巧将其简化。
        
    4. 过长参数列表
        - 过长的参数列表会增加函数的复杂性。
        - 如果一个参数可以通过查询获得另一个参数的值，使用“以查询取代参数”技巧；
        - 如果多个参数来自同一个数据结构，使用“保持对象完整”；
        - 当一组参数总是一起出现时，使用“引入参数对象”将它们合并；
        - 对于用来区分函数行为的标记参数，使用“移除标记参数”技巧。
        - 此外，如果多个函数使用相同的参数，考虑创建一个类，将这些参数作为类的字段，有效地简化参数传递。
        
    5. 全局数据
        - 全局数据的主要问题是它可以被程序的任何部分修改，导致难以调试的 bug。
        - 全局变量、类变量、以及单例模式都会面临这种风险。
        - 最常见的解决方案是“封装变量”，通过函数对全局数据进行包装，至少可以追踪数据的修改源。进一步的优化是将数据移到类或模块中，只允许内部使用。
        - 如果全局数据是只读的，相对安全，但仍需编程语言提供明确的只读保证。
        - 总体上，全局数据应尽量减少并封装，以减少代码的复杂性和维护成本。
    6. 可变数据
        - 对数据的修改经常导致出乎意料的结果和难以发现的 bug，尤其当多个功能依赖同一数据时。降低风险的措施如下：
        1. 封装变量：通过少数函数更新数据，便于监控。
        2. 拆分变量：不同用途的数据使用不同变量，减少风险。
        3. 分离查询与修改：避免查询时修改数据。
        4. 移除设值函数：减少不必要的设值操作。
        5. 以查询取代派生变量：避免存储可以计算出的数据。
        - 局部变量作用范围小，它的问题相对不大，但随着作用域的扩大，它的问题风险增加。
        - 通过优化代码结构和变量管理，可以有效控制数据修改的影响。
    7. 发散式变化
        - 当模块因不同原因，在不同方向上频繁变动时，代码会难以维护和理解。
        - 修改一个模块需同时更改多个函数，便是发散式变化的表现。解决策略如下：
        1. 分离上下文：将不同的功能（如数据库交互和业务逻辑）分成独立模块，方便针对特定上下文进行修改。
        2. 拆分阶段：如果变化有自然的顺序，使用拆分阶段将两者分开，通过清晰的数据结构进行交互。
        3. 搬移函数：如果两个方向间有频繁调用，先创建适当模块，后用搬移函数分离处理逻辑。
        4. 提炼函数和类：对于混合逻辑的函数，先提炼函数，再搬移；如果模块是类，使用提炼类进行拆分。
        - 通过这些手段，能够让程序更具可维护性，降低因发散式变化引起的复杂性。
        
    8. 霰弹式修改
        - 霰弹式修改是指在变更时需要在多个类中进行许多小修改，导致代码分散，难以管理。解决方法包括：
        1. 搬移函数和字段：集中相关代码到一个模块。
        2. 函数组合成类：将处理相似数据的函数组合为一个类。
        3. 函数组合成变换：将转换或增强数据的函数组合在一起。
        4. 拆分阶段：将输出可组合的函数分开。
        - 可以使用内联重构，如内联函数或类，集中逻辑等重构方式，尽管这可能导致出现较大单元，但后续可以通过提炼重构来细分。

        
    9. 依恋情结
        - 依恋情结指的是一个函数频繁与其他模块的函数或数据交互，而不是与自身模块交互。解决方法包括：
        1. 使用搬移函数将需要频繁交互的函数移至相关模块。
        2. 如果函数只有部分依赖其他模块，提炼出该部分并独立成函数后再搬移。
        - 当函数需要使用多个模块的功能时，判断哪个模块拥有的数据最多，然后将函数与这些数据放在一起。
        - 对复杂函数，先提炼成小函数再决定其归属。
        - 某些设计模式（如策略模式和访问者模式）可以帮助管理发散式变化，保持相关行为和数据在一起，以减少修改影响。尽管这增加了它的间接性，但这也有效地管理了代码变化。

        
    10. 数据泥团
        - 数据泥团是指多个地方重复出现的相关数据。应将这些数据提炼为独立对象。
        - 首先，通过提炼类将重复数据整合到新对象中，然后使用引入参数对象或保持对象完整来简化函数签名。这可以缩短参数列表，提高函数调用的简洁性。
        - 如果删除一项数据会导致其他数据失去意义，那么这说明你应为它们创建新对象。
        - 新建类不仅有助于消除重复，还能提升后续开发效率。
    11. 基本类型偏执
        - 基本类型偏执是指过度依赖整数、字符串等基本类型，而不愿创建适合问题域的自定义类型。
        - 比如，将钱、坐标或范围等关键数据仅仅当作数字或字符串处理，忽视了它们应有的逻辑和约束。
        - 为解决此问题，可以使用以对象取代基本类型的重构手法，创建更具意义的对象。这样不仅能简化代码逻辑，还能减少潜在错误。
    12. 重复的switch
        - 重复的 switch 语句容易引发问题——每次新增分支时，必须手动更新所有 switch 语句。
        - 使用以多态取代条件表达式的方式，可以简化逻辑，避免重复修改，提升代码维护性。
    13. 循环语句
        - 循环曾经是编程的核心，但随着编程语言的发展，管道操作（如 filter 和 map）已经成为更好的替代方案。相比传统的循环，管道能更直观地表达数据处理的意图，使代码更简洁易懂。
        - 通过**以管道取代循环**，可以让代码变得更具可读性和灵活性，从而告别传统的循环语句。
        - map、filter 和 reduce (C#中为Aggregate) 是主要的三个管道。
    14. 冗赘的元素
        - 有时，程序中的类或函数并没有实际提供额外的结构，只是冗余的包装。
        - _可能在编程中，它存在复杂化的可能，但实际并未复杂化；或者经过重构后，它的功能变得过于简单。_
        - 此时，可以使用**内联函数**或**内联类**来移除这些多余的结构。如果该类位于继承体系中，则可以使用**折叠继承体系**将其简化。
    15. 夸夸其谈通用性
        - 当程序中为未来的某些潜在需求加入过多钩子或处理特殊情况时，往往会导致系统复杂化，难以理解和维护。如果这些功能未被实际使用，它们就是不必要的负担。
        - 为此，可以使用**折叠继承体系**来简化无用的抽象类，运用**内联函数**或**内联类**移除不必要的委托。
        - 如果函数参数无用，可以通过**改变函数声明**将其移除。
        - 若某个类或函数仅用于测试，则考虑移除测试用例并使用**移除死代码**处理这些无效部分。
    16. 临时字段
        - 当类中的某个字段仅在特定情况下使用时，会导致理解困难。
        - 应使用**提炼类**为该字段创建新类，并用**搬移函数**将相关代码移至新类。
        - 如果需要处理特定情况，可以使用**引入特例**创建替代对象，以避免条件判断。
    17. 过长的消息链
        - 消息链是指用户向一个对象请求另一个对象，然后依次请求多个对象。这种做法会导致客户端代码与对象之间的导航结构紧密耦合，若对象关系变化，客户端代码也需修改。
        - 解决方法是使用**隐藏委托关系**，在消息链的不同位置进行重构。
        - 通常，首先观察消息链最终对象的用途，通过**提炼函数**将相关代码提取到独立函数中，再使用**搬移函数**将其整合到消息链中。
        - 如果有其他客户端代码需要访问链上其他对象，可以添加相应函数处理。
        - 并非所有函数链都是坏的，合理使用仍然可以保持代码的灵活性。
    18. 中间人
        - 中间人的概念在于封装和委托的使用。对象可以通过封装隐藏其内部细节，但过度委托可能导致接口复杂化。如果一个类的函数中有大量委托到其他类，这种情况就称为中间人。
        - 遇到这种情况，可以选择**移除中间人**，直接与真正负责的对象交互。
        - 如果只存在少数不必要的委托函数，可以使用**内联函数**将其合并到调用端。
        - 如果中间人类还具有其他功能，可以考虑使用**以委托取代超类**或**以委托取代子类**，将其转换为具有扩展行为的对象，从而减少不必要的委托。
    19. 内幕交易
        - 内幕交易指的是模块之间的隐秘数据交换，这种做法增加了模块间的耦合性。
        - 为了减少这种隐秘交流，应该使用**搬移函数**和**搬移字段**，使数据交换变得更加透明。
        - 如果两个模块有共同的数据需求，可以考虑创建一个新模块来集中管理这些共享数据，或者使用**隐藏委托关系**将一个模块转变为中介。
        - 此外，继承关系也可能导致信息泄露，因为子类往往对超类的信息掌握过多。如果发现这种情况，可以考虑使用**以委托取代子类**或**以委托取代超类**的方式，让子类独立于继承体系。
    20. 过大的类
        - 当一个类承担了过多职责时，通常会出现大量字段，并导致代码重复。 
        - 为了解决这个问题，可以使用**提炼类**将相关的字段提炼到一个新的类中。通常，具有相同前缀或后缀的字段是提炼的良好候选。
        - 如果类中的字段并非在所有时候都被使用，可以考虑进行多次提炼。 
        - 同样，当类内部代码过多时，也会导致重复和混乱。一个简单的解决方案是简化类内部的实现。如果存在多个相似的长函数，可以将它们拆分成更小的函数。
        - 通过观察类的使用者，通常可以找到拆分类的线索。如果使用者只需用到某个功能子集，可以使用**提炼类**、**提炼超类**或**以子类取代类型码**将其拆分成独立的类。
    21. 异曲同工的类
        - 类的一个主要优点是可以进行替换，但需确保两个类的接口一致。
        - 可以使用改变函数声明使函数签名一致。
        - 可以通过反复使用搬移函数将相关行为移入类中，直到两者的协议一致为止。
        - 如果在搬移过程中出现了代码重复，可以考虑使用提炼超类来消除这些重复。
    22. 纯数据类
        - 纯数据类是只包含字段和读写这些字段的函数的类，它容易被其他类过度操控。
        - 首先，对于这些类，应当封装其中的字段，并移除不应修改的字段的设值函数。
        - 接着，将调用逻辑尽可能搬移到数据类中，必要时提炼出可搬移的函数。
        - 通常，我们应将行为与数据绑定，但某些不可修改的中转数据结构除外。
    23. 被拒绝的遗赠
        - "被拒绝的遗赠"指子类继承了超类的行为或数据，但只用了一部分。
        - 传统解决方法是通过函数下移和字段下移调整继承结构。
        - 在大多数情况下，这种坏味道不强，可以忽略。
        - 但是，如果子类不愿支持超类的接口而继承其实现，这会引发更严重的问题，此时应考虑以委托取代子类或超类。
    24. 注释
        - **当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。**
        - 注释本身并不是坏味道，但它们常被用来掩盖糟糕的代码。
        - 当你发现需要注释时，应该先考虑通过重构来使代码自解释，比如提炼函数或改变函数声明。
        - 注释的最佳用途是记录开发者的意图、未来的计划或不确定的地方，而不是解释复杂的代码逻辑。
    
22. 构筑测试体系
    - 重构是很有价值的工具，但只有重构还不行。要正确地进行重构，前提是得有一套稳固的测试集合，以发现难以避免的疏漏。
    1. 确保所有测试都完全自动化，让它们检查自己的测试结果。
    2. 一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需的时间。
    3. 每当你收到 bug 报告，请先写一个单元测试来暴露这个 bug。
 
---

## 重构的记录格式
- 名称：重构的名称及常见别名  
    1. 速写：帮助快速识别重构手法  
    2. 动机：解释该重构的必要性和适用情况  
    3. 做法：分步介绍如何执行重构  
    4. 范例：通过简单例子展示重构手法

## 重构名录：第一组重构
### 1.提炼函数
速写：

```JavaScript
function printOwing(invoice) {

    printBanner();

    let outstanding = calculateOutstanding();

    // print details
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
}

function printOwing(invoice) {

    printBanner();

    let outstanding = calculateOutstanding();

    printDetails(outstanding);

    function printDetails(outstanding) {
        console.log(`name: ${invoice.customer}`);
        console.log(`amount: ${outstanding}`);
    }
}
```

动机：将代码意图与实现分离，使代码更易读、易理解。

对于那些需要花时间理解的代码，应将其提炼到独立的函数中，并以描述其功能的名称命名。

提炼小函数有助于简化代码结构，即便函数短小也不必担心性能问题。

良好的命名对小函数至关重要，这需要不断练习。

